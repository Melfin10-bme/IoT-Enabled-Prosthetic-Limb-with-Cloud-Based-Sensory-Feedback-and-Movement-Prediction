// --- INCLUDE YOUR TRAINED AI MODEL ---
// This file is generated by the Python notebook.
#include "model.h"

// --- CREATE AN INSTANCE OF THE AI MODEL ---
// The classname 'ProstheticHandModel' must match the 'classname' in your Python notebook
Eloquent::ML::Port::ProstheticHandModel model;

// --- BLYNK CONFIGURATION ---
#define BLYNK_TEMPLATE_ID "TMPL3DZyCh99j"
#define BLYNK_TEMPLATE_NAME "new"
#define BLYNK_AUTH_TOKEN "m9HY-VvKVE3yfa3kqXaaVY20Jk1hVtg0"
#define BLYNK_PRINT Serial
#include <WiFi.h>
#include <BlynkSimpleEsp32.h>
char auth[] = "m9HY-VvKVE3yfa3kqXaaVY20Jk1hVtg0";
char ssid[] = "Nothing Phone (2a)_5222";
char pass[] = "100200300";
// --- I2C & COMPONENT LIBRARIES ---
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_ADXL345_U.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_PWMServoDriver.h>

// --- PIN DEFINITIONS ---
#define I2C_SDA 21
#define I2C_SCL 22
#define FSR1_PIN 34
#define FSR2_PIN 35
#define TRIG_PIN 12
#define ECHO_PIN 14
#define VIB_SENSOR_PIN 27
#define VIB_MOTOR_PIN 26

// --- OLED DISPLAY SETUP ---
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// --- ACCELEROMETER SETUP ---
Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345);

// --- SERVO DRIVER SETUP ---
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver();
#define SERVO_FREQ 50
// Note: The model will predict values in this range, e.g., 150-600
#define SERVOMIN 150
#define SERVOMAX 600

// --- GLOBAL VARIABLES ---
int fsr1_val = 0;
int fsr2_val = 0;
int grip_pressure_avg = 0;
float accelX = 0.0, accelY = 0.0, accelZ = 0.0;
long distance_cm = 0;
int vibration_state = 0;
String motion_direction = "Static";
// int ai_predicted_pulse = SERVOMIN; // No longer the main AI output
int current_gesture = 0; // NEW: Variable for AI gesture output (0 = Rest)

// --- GRAPHING VARIABLES ---
#define GRAPH_WIDTH 128
#define GRAPH_HEIGHT 30
int gripHistory[GRAPH_WIDTH];
int graph_bottom_y = SCREEN_HEIGHT - 1;

void setup() {
  Serial.begin(115200);
  Serial.println("Prosthetic Hand System: AI CONTROL MODE");
  Serial.println("Loading AI model...");
  // The model is loaded automatically from model.h
  Serial.println("AI Model OK.");

  Wire.begin(I2C_SDA, I2C_SCL);

  // --- Initialize OLED Display ---
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;);
  }
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.println("OLED Init: OK");
  display.println("MODE: AI CONTROL");
  display.display();
  delay(1000);

  // --- Initialize Accelerometer ---
  if (!accel.begin()) {
    Serial.println("Could not find ADXL345 sensor!");
    while (1) delay(10);
  }
  accel.setRange(ADXL345_RANGE_4_G);

  // --- Initialize Servo Driver ---
  pwm.begin();
  pwm.setPWMFreq(SERVO_FREQ);

  // --- Initialize Other GPIO Pins ---
  pinMode(FSR1_PIN, INPUT);
  pinMode(FSR2_PIN, INPUT);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  pinMode(VIB_SENSOR_PIN, INPUT_PULLUP);
  pinMode(VIB_MOTOR_PIN, OUTPUT);
  digitalWrite(VIB_MOTOR_PIN, LOW);

  // --- MOTOR TEST ---
  Serial.println("Testing vibration motor ON for 2 seconds...");
  digitalWrite(VIB_MOTOR_PIN, HIGH);
  delay(2000);
  digitalWrite(VIB_MOTOR_PIN, LOW);
  Serial.println("Motor test OFF. Resuming boot.");
  // --- END MOTOR TEST ---

  for (int i = 0; i < GRAPH_WIDTH; i++) {
    gripHistory[i] = 0;
  }

  // --- Connect to WiFi and Blynk ---
  Blynk.begin(auth, ssid, pass);
  Serial.println("Blynk Connected!");
  delay(1000);
}

void loop() {
  Blynk.run();
  
  readSensors();
  updateServos_AI(); // *** USE THE AI PREDICTION ***
  updateOLED();
  checkVibration();
  sendDataToBlynk();
  
  delay(50); 
}

void readSensors() {
  // Read all sensors as before
  fsr1_val = analogRead(FSR1_PIN);
  fsr2_val = analogRead(FSR2_PIN);
  grip_pressure_avg = (fsr1_val + fsr2_val) / 2;

  sensors_event_t event;
  accel.getEvent(&event);
  accelX = event.acceleration.x;
  accelY = event.acceleration.y;
  accelZ = event.acceleration.z;
  
  if (accelX > 7.0) motion_direction = "Right";
  else if (accelX < -7.0) motion_direction = "Left";
  else if (accelY > 7.0) motion_direction = "Up";
  else if (accelY < -7.0) motion_direction = "Down";
  else if (abs(accelX) < 2.0 && abs(accelY) < 2.0 && accelZ > 8.0) motion_direction = "Static";

  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  long duration = pulseIn(ECHO_PIN, HIGH);
  distance_cm = duration * 0.034 / 2;

  vibration_state = digitalRead(VIB_SENSOR_PIN);
  
  // --- SENSOR DEBUG ---
  Serial.print("Vibration Sensor State: ");
  Serial.println(vibration_state); // Will print 1 (HIGH) or 0 (LOW)
  // --- END SENSOR DEBUG ---
}

void updateServos_AI() {
  // --- AI PREDICTION (NEW GESTURE MODEL) ---
  // 1. Create the input features array for the model
  // MUST be in the *exact same order* as in the Python notebook
  float features[] = {
    (float)fsr1_val,
    (float)fsr2_val,
    accelX,
    accelY,
    accelZ
  };

  // 2. Call the model's predict function
  // This function comes from your NEW 'model.h' file
  // *** IMPORTANT: You must re-train your AI model as a CLASSIFIER ***
  // *** It must output 0 (Rest), 1 (Fist), 2 (Pinch), or 3 (Point) ***
  current_gesture = (int)model.predict(features);
  
  // 3. Implement the gesture logic using a switch case
  // I have filled in example servo values for you
  switch (current_gesture) {
    case 1: // FIST
      // move all 4 servos to "closed"
      // Assuming Servo 0 is Thumb, 1=Index, 2=Middle, 3=Ring
      pwm.setPWM(0, 0, SERVOMAX); 
      pwm.setPWM(1, 0, SERVOMAX);
      pwm.setPWM(2, 0, SERVOMAX);
      pwm.setPWM(3, 0, SERVOMAX);
      break;
      
    case 2: // PINCH
      // move only thumb and index finger servos
      pwm.setPWM(0, 0, SERVOMAX); // Thumb closed
      pwm.setPWM(1, 0, SERVOMAX); // Index closed
      pwm.setPWM(2, 0, SERVOMIN); // Middle open
      pwm.setPWM(3, 0, SERVOMIN); // Ring open
      break;
      
    case 3: // POINT
      // move all servos closed, except index finger
      pwm.setPWM(0, 0, SERVOMAX); // Thumb closed
      pwm.setPWM(1, 0, SERVOMIN); // Index open
      pwm.setPWM(2, 0, SERVOMAX); // Middle closed
      pwm.setPWM(3, 0, SERVOMAX); // Ring closed
      break;
      
    default: // REST (Gesture 0 or any other number)
      // move all servos to "open"
      pwm.setPWM(0, 0, SERVOMIN);
      pwm.setPWM(1, 0, SERVOMIN);
      pwm.setPWM(2, 0, SERVOMIN);
      pwm.setPWM(3, 0, SERVOMIN);
      break;
  }
}

void updateOLED() {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  
  display.setCursor(0, 0);
  display.print("Dir: ");
  display.println(motion_direction);

  display.setCursor(0, 9);
  display.print("Grip: ");
  display.print(grip_pressure_avg);
  
  display.setCursor(64, 9);
  display.print("Dist: ");
  display.print(distance_cm);
  display.println("cm");

  display.setCursor(0, 18);
  // Display the AI's output gesture
  display.print("AI Gesture: ");
  display.print(current_gesture);
  
  drawGraph();
  display.display();
}

void drawGraph() {
  for (int i = 0; i < GRAPH_WIDTH - 1; i++) {
    gripHistory[i] = gripHistory[i + 1];
  }
  int mapped_grip = map(grip_pressure_avg, 0, 4095, 0, GRAPH_HEIGHT);
  gripHistory[GRAPH_WIDTH - 1] = constrain(mapped_grip, 0, GRAPH_HEIGHT);
  
  for (int x = 0; x < GRAPH_WIDTH; x++) {
    display.drawFastVLine(x, graph_bottom_y - gripHistory[x], gripHistory[x], SSD1306_WHITE);
  }
  display.drawFastHLine(0, graph_bottom_y, GRAPH_WIDTH, SSD1306_WHITE);
}

void checkVibration() {
  // Logic: Turn motor ON (HIGH) only when sensor is LOW (vibration)
  digitalWrite(VIB_MOTOR_PIN, (vibration_state == LOW) ? HIGH : LOW);
}

void sendDataToBlynk() {
  Blynk.virtualWrite(V0, grip_pressure_avg);
  Blynk.virtualWrite(V1, distance_cm);
  Blynk.virtualWrite(V2, accelX);
  Blynk.virtualWrite(V3, accelY);
  Blynk.virtualWrite(V4, accelZ);
  Blynk.virtualWrite(V5, motion_direction);
  Blynk.virtualWrite(V6, current_gesture); // Send AI gesture to Blynk
}

